
import XOF
import hashlib
import logging
from Crypto.Hash import SHAKE128


# Basic configuration of logging
logging.basicConfig(
    level=logging.DEBUG,  # Set the log level
    format='%(asctime)s - %(levelname)s - %(message)s',  # Define log format
    handlers=[logging.StreamHandler()]  # Log to standard output (console)
)


#All global parameters defined in the ML-KEM parameter set. Went with MNL-KEM-1024 but can be easily altered.

n = 256
q=3329
k = 4
eta = 2 #eta1 and eta2 are the same value sete in the apporved parameter set
d1 = 11 #d^u is what is defined on the parameter set but easier to type as d1
d2 = 5 #d^v is what is defined on the parameter set but easier to type as d2

tempd = 12 #This is generated by "ML-KEM.KeyGen_internal" but function not implemented so just set to 12 for now.

primitiveRoot = 3 # primitive of root of "q". Shouldnt need to be changed but if q is changed it will need to be changed. Made global as used by mutliple functions.


def BitsToBytes(input_data): #Converts array of bits to array of bytes. 
    length = len(input_data)
    bytesArray = []
    if length % 8 == 0:
        for x in range(0, length, 8):
            tempArray = input_data[x:x+8]  # gets 8 integers and stores in temp.
            tempString = ""
            for y in range(0,8):
                tempString += str(tempArray[y])
            bytesArray.append(int(tempString, 2))  # Appends byte to array as integer. Easier to read and easily convertible to byte. 


    else:
        print("Function BitsToBytes failed. Inputted Array was not of length.")

    return bytes(bytesArray)

def BytesToBits(input_data): #Converts array of bytes to bits and stores them individually.
    length = len(input_data)
    bytesArray = []
    for x in range(length):
        temp = format(input_data[x], '08b')
        for y in range(0,8):
            bytesArray.append(int(temp[y]))
        
    return bytesArray


def ByteEncode(input_data, d): #TODO Need to add d
    byteArray = []
    if(len(input_data) == 256):
        for temp in input_data:
            for y in range(d):
                byteArray.append(temp % 2) # Gets the first bit in the input
                temp >>= 1 #Shifts bit by 1
        
        byteArray = BitsToBytes(byteArray)    

    else:
        print("Function ByteEncode failed. Inputted Array was not of length. The length was: ", len(input_data))

    return byteArray


def ByteDecode(input_data, d): #TODO Need to add d variable.
    bitsArray = BytesToBits(input_data)
    byteArray = []
    if (len(bitsArray) == 256):
        for x in range(0, len(bitsArray), d):
            temp = 0
            for y in range(d):
                if(y+ x < len(bitsArray)):     
                    temp = (bitsArray[y+x]*(2**y)) + temp #Gets d bits following x and coverts to integer
            
            temp = temp % q
            byteArray.append(temp)

    else:
        print("Function ByteDecode failed. Inputted Array was not of length. The length was: ", len(bitsArray))
    return byteArray

def SampleNTT(input_data):
    ctx = SHAKE128.new(input_data)
    
    output = []
    j = 0
    while j != 256:
        C = ctx.read(3)   
        d1 = C[0] + 256 * (C[1] % 16)
        d2 = (C[1]//16) + 16*C[2]

        if d1 < q:
            output.append(d1)
            j += 1
        if d2 < q and j < 256:
            output.append(d2)
            j += 1


    return output    

def SamplePolyCBD(input_data, length):
    bits = BytesToBits(input_data)
    output = []
    for x in range(256):
        temp1 = 0
        temp2 = 0
        for y in range(eta-1):
            temp1 += bits[2 * x * length + y]

        for y in range(eta-1):
            temp2 += bits[2 * x * length + length + y]   
        output.append((temp1-temp2) % q)
    return output


def BitReverse(input, bitLength): #Needed for the NTT function
    reversedInput = 0
    for x in range(bitLength):
        reversedInput = (reversedInput << 1) | (input & 1)
        input >>= 1
    return reversedInput



def NTT(input_data):
    primitiveRoot = 3 # primitive of root of "q". Shouldnt need to be changed but if q is changed it will need to be changed.
    inputCopy = input_data[:]
    
    i = 1
    length = 128
    
    while (length >= 2):
        start = 0
        while(start < 256):
            reversedBit = BitReverse(i,7)
            zeta = pow(primitiveRoot, reversedBit, q) # Is basically just doing prime^bit mod q but in a more efficient way.
            i += 1
            j = start
            while(j < start + length):
                
                t = (zeta * inputCopy[j+length] ) % q
                inputCopy[j+length] = (inputCopy[j] - t) % q 
                inputCopy[j] = (inputCopy[j] + t) % q
                j += 1
            start += (2*length)
        length = length//2

    return inputCopy

def NTTi(input_data):

    inputCopy = input_data[:]
    i = 127
    length = 2
    while (length <= 128):
        start = 0
        while(start < 256):
            reversedBit = BitReverse(i,7)
            zeta = pow(primitiveRoot, reversedBit, q) # Is basically just doing prime^bit mod q but in a more efficient way. # TODO IMPLEMENT EVERYWHERE WITH MOD 
            i += 1
            j = start
            while(j < start + length):
                t = inputCopy[j]
                inputCopy[j]= t + inputCopy[f+length]
                inputCopy[j+length] = zeta* (inputCopy[j+length]-t)
                j += 1
            start += (2*length)
        length = 2*length
    inputCopy = pow
    return inputCopy

def BaseCaseMultiply(a0,a1,b0,b1,gamma):
    c0 = (a0*b0+a1*b1*gamma) % q
    c1 = (a0*b1+a1*b0) % q
    return(c0,c1)



def MultiplyNTTs(f,g):
    h = [0] * 256
    for i in range(128):
        (h[2*i], h[2*i+1]) = BaseCaseMultiply(f[2*i],f[2*i+1],g[2*i],g[2*i+1], pow(primitiveRoot, BitReverse(i,7)+1))
    return(h)

def BaseCaseMultiply(a0, a1, b0, b1, gamma):
    c0 = (a0 * b0 + a1 * b1 * gamma) % q
    c1 = (a0 * b1 + a1 * b0) % q

    return c0, c1

def G(input_data):
    Hash =hashlib.sha3_512()
    Hash.update(input_data)

    HashOutput = Hash.digest()

    output1 = HashOutput[0:32] # This is the first 32 bytes of the hash
    output2 = HashOutput[32:64] # This is the second 32 bytes of the hash
    return output1, output2 # Returns the two psuedo random 32 byte outputs
    


        
def toStringOfBytes(input_data):
    output_data = b""
    for i in range(len(input_data)):
        output_data += bytes([input_data[i]])
    return output_data  